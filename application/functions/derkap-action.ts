import { supabase } from "@/lib/supabase";
import { UUID } from "crypto";
import { DERKAP_PHOTOS_BUCKET_NAME } from "@/lib/constants";
import { TDerkapDB } from "@/types/types";
import { decryptPhoto } from "./encryption-action";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { getEncryptionKey } from "./encryption-action";

const generateRandomId = () => {
  return Math.random().toString(36).substring(2, 15);
};

const generatePostPath = ({
  challenge,
  user_id,
}: {
  challenge: string;
  user_id: string;
}) => {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 15);
  return `user_${user_id}/${timestamp}_${random}`;
};

export const uploadDerkapToDB = async ({
  challenge,
  encrypted_post,
  caption,
  allowed_users,
  derkap_base_key,
}: {
  challenge: string;
  encrypted_post: Buffer;
  caption: string;
  allowed_users: UUID[];
  derkap_base_key: string;
}) => {
  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }
  const filePath = generatePostPath({
    user_id,
    challenge,
  });

  const { error: errorUpload } = await supabase.storage
    .from(DERKAP_PHOTOS_BUCKET_NAME)
    .upload(filePath, encrypted_post, {
      upsert: true,
    });

  if (errorUpload) {
    throw new Error(errorUpload.message);
  }

  const allowedUsersWithUser = [...allowed_users, user_id];

  const uniqueAllowedUsers = [...new Set(allowedUsersWithUser)];

  // Call the RPC function to insert the derkap and allowed users in one request
  const { data, error } = await supabase.rpc("insert_derkap_with_users", {
    p_challenge: challenge,
    p_caption: caption,
    p_allowed_users: uniqueAllowedUsers,
    p_base_key: derkap_base_key,
    p_file_path: filePath,
    p_user_id: user_id,
  });

  if (error) {
    console.log("error", error);
    throw new Error(error.message);
  }
};

/*
create table
  public.derkap_allowed_users (
    derkap_id bigint not null,
    allowed_user_id uuid not null,
    created_at timestamp with time zone not null default now(),
    constraint derkap_permissions_pkey primary key (derkap_id, allowed_user_id),
    constraint fk_user foreign key (allowed_user_id) references profile (id) on delete cascade,
    constraint derkap_allowed_users_derkap_id_fkey foreign key (derkap_id) references derkap (id) on delete cascade
  ) tablespace pg_default;
*/

/*
create table
  public.derkap (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone not null default now(),
    challenge text null,
    creator_id uuid null,
    caption text null,
    file_path text null,
    base_key text null,
    constraint derkap_pkey primary key (id),
    constraint derkap_creator_id_fkey foreign key (creator_id) references profile (id)
  ) tablespace pg_default;
*/

export const fetchDerkaps = async ({
  page,
}: {
  page: number;
}): Promise<TDerkapDB[]> => {
  const RESULT_PER_PAGE = 6;

  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }

  // Calculate pagination offset
  const offset = (page - 1) * RESULT_PER_PAGE;

  // Query the derkap table while joining with derkap_allowed_users and profile

  // // get derkap allowed users profiles using derkap_allowed_users.allowed_user_id and profile.id
  // // const { data, error } = await supabase
  //   .from("derkap")
  //   .select(
  //     `
  //     id,
  //     created_at,
  //     challenge,
  //     caption,
  //     file_path,
  //     base_key,
  //     creator_id,
  //     creator:creator_id (
  //       id,
  //       username,
  //       avatar_url,
  //       created_at,
  //       email
  //     ),
  //     derkap_allowed_users(
  //       profile(*)
  //     )
  //   `,
  //   )
  //   .eq("derkap_allowed_users.allowed_user_id", user_id) // Only return derkaps the user is allowed to see
  //   .order("created_at", { ascending: false }) // Order by most recent first
  //   .range(offset, offset + RESULT_PER_PAGE - 1); // Apply pagination

  const { data, error } = await supabase
    .from("derkap_allowed_users")
    .select(
      `
      *,
      derkap(
        id,
        created_at,
        challenge,
        caption,
        file_path,
        base_key,
        creator_id,
        derkap_allowed_users(
          profile(*)
        ),
        creator:creator_id(
          id,
          username,
          avatar_url,
          created_at,
          email
      )
    )
    `,
    )
    .eq("allowed_user_id", user_id) // Only return derkaps the user is allowed to see
    .order("created_at", { ascending: false }) // Order by most recent first
    .range(offset, offset + RESULT_PER_PAGE - 1); // Apply pagination

  if (error) {
    console.error("Error fetching derkap timeline:", error);
    throw new Error(error.message);
  }

  if (data.length === 0) {
    return [];
  }

  const derkapsWithoutPhotos = data.map((derkap) => ({
    ...derkap.derkap,
    derkap_allowed_users: derkap.derkap.derkap_allowed_users.map(
      (user) => user.profile,
    ),
  }));

  const derkapsWithPhotos = await addPhotosToDerkaps({
    derkaps: derkapsWithoutPhotos,
  });

  return derkapsWithPhotos;
};

const addPhotosToDerkaps = async ({
  derkaps,
}: {
  derkaps: Omit<TDerkapDB, "base64img">[];
}): Promise<TDerkapDB[]> => {
  const derkapsWithPhotosPromises: Promise<TDerkapDB>[] = derkaps.map(
    async (derkap: Omit<TDerkapDB, "base64img">) => {
      const filePath = derkap.file_path;
      const key = `photo_${derkap.id}`;

      const cached_photo = await AsyncStorage.getItem(key);
      if (cached_photo) {
        return {
          ...derkap,
          base64img: cached_photo,
        };
      }

      const { data: file, error: errorDownload } = await supabase.storage
        .from(DERKAP_PHOTOS_BUCKET_NAME)
        .download(filePath);
      if (errorDownload) {
        throw new Error(errorDownload.message);
      }

      const encryptionKey = await getEncryptionKey({
        derkap_id: derkap.id,
      });

      const decryptedPost = await decryptPhoto({
        encryptedBlob: file,
        encryptionKey,
      });

      const photo = `data:image/jpeg;base64,${decryptedPost}`;

      await AsyncStorage.setItem(key, photo);

      return {
        ...derkap,
        base64img: photo,
      };
    },
  );

  const derkapsWithPhotos = await Promise.all(derkapsWithPhotosPromises);

  return derkapsWithPhotos;
};

export const fetchAllMyChallenges = async (): Promise<string[]> => {
  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }

  const CHUNK_SIZE = 100;
  const challenges: string[] = [];
  let hasMore = true;
  let offset = 0;

  while (hasMore) {
    const { data, error } = await supabase
      .from("derkap")
      .select("challenge")
      .eq("creator_id", user_id)
      .order("created_at", { ascending: false })
      .range(offset, offset + CHUNK_SIZE - 1);

    if (error) {
      throw new Error(error.message);
    }

    challenges.push(...data.map((derkap) => derkap.challenge));

    if (data.length < CHUNK_SIZE) {
      hasMore = false;
    }

    offset += CHUNK_SIZE;
  }

  return challenges;
};

export const deleteDerkap = async ({ derkap_id }: { derkap_id: number }) => {
  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }
  const { error } = await supabase
    .from("derkap")
    .delete()
    .eq("id", derkap_id)
    .eq("creator_id", user_id);
  if (error) {
    throw new Error(error.message);
  }
};
