import { supabase } from "@/lib/supabase";
import { UUID } from "crypto";
import { DERKAP_PHOTOS_BUCKET_NAME } from "@/lib/constants";
import { TDerkapDB, TProfileDB } from "@/types/types";
import { decryptPhoto } from "./encryption-action";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { getEncryptionKey } from "./encryption-action";

const generatePostPath = ({
  challenge,
  user_id,
}: {
  challenge: string;
  user_id: string;
}) => {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 15);
  return `user_${user_id}/${timestamp}_${random}`;
};

export const uploadDerkapToDB = async ({
  challenge,
  encrypted_post,
  caption,
  allowed_users,
  derkap_base_key,
}: {
  challenge: string;
  encrypted_post: Buffer;
  caption: string;
  allowed_users: UUID[];
  derkap_base_key: string;
}) => {
  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }
  const filePath = generatePostPath({
    user_id,
    challenge,
  });

  const { error: errorUpload } = await supabase.storage
    .from(DERKAP_PHOTOS_BUCKET_NAME)
    .upload(filePath, encrypted_post, {
      upsert: true,
    });

  if (errorUpload) {
    throw new Error(errorUpload.message);
  }

  const allowedUsersWithUser = [...allowed_users, user_id];

  const uniqueAllowedUsers = [...new Set(allowedUsersWithUser)];

  // Call the RPC function to insert the derkap and allowed users in one request
  const { data, error } = await supabase.rpc("insert_derkap_with_users", {
    p_challenge: challenge,
    p_caption: caption,
    p_allowed_users: uniqueAllowedUsers,
    p_base_key: derkap_base_key,
    p_file_path: filePath,
    p_user_id: user_id,
  });

  if (error) {
    console.log("error", error);
    throw new Error(error.message);
  }
};

/*
create table
  public.derkap_allowed_users (
    derkap_id bigint not null,
    allowed_user_id uuid not null,
    created_at timestamp with time zone not null default now(),
    constraint derkap_permissions_pkey primary key (derkap_id, allowed_user_id),
    constraint fk_user foreign key (allowed_user_id) references profile (id) on delete cascade,
    constraint derkap_allowed_users_derkap_id_fkey foreign key (derkap_id) references derkap (id) on delete cascade
  ) tablespace pg_default;
*/

/*
create table
  public.derkap (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone not null default now(),
    challenge text null,
    creator_id uuid null,
    caption text null,
    file_path text null,
    base_key text null,
    constraint derkap_pkey primary key (id),
    constraint derkap_creator_id_fkey foreign key (creator_id) references profile (id)
  ) tablespace pg_default;
*/

export const fetchDerkaps = async ({
  page,
}: {
  page: number;
}): Promise<TDerkapDB[]> => {
  const RESULT_PER_PAGE = 6;

  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }

  // Calculate pagination offset
  const offset = (page - 1) * RESULT_PER_PAGE;

  // Query the derkap table while joining with derkap_allowed_users and profile

  const { data, error } = await supabase
    .from("derkap_allowed_users")
    .select(
      `
      *,
      derkap(
        id,
        created_at,
        challenge,
        caption,
        file_path,
        base_key,
        creator_id,
        derkap_allowed_users(
          profile(*)
        ),
        creator:creator_id(
          id,
          username,
          avatar_url,
          created_at,
          email
      )
    )
    `,
    )
    .eq("allowed_user_id", user_id) // Only return derkaps the user is allowed to see
    .order("created_at", { ascending: false }) // Order by most recent first
    .range(offset, offset + RESULT_PER_PAGE - 1); // Apply pagination

  if (error) {
    console.error("Error fetching derkap timeline:", error);
    throw new Error(error.message);
  }

  if (data.length === 0) {
    return [];
  }

  const derkapsWithoutPhotos = data.map((derkap) => ({
    ...derkap.derkap,
    derkap_allowed_users: derkap.derkap.derkap_allowed_users.map(
      (user) => user.profile,
    ),
  }));

  const derkapsWithPhotos = await addPhotosToDerkaps({
    derkaps: derkapsWithoutPhotos,
  });

  return derkapsWithPhotos;
};

const addPhotosToDerkaps = async ({
  derkaps,
}: {
  derkaps: Omit<TDerkapDB, "base64img">[];
}): Promise<TDerkapDB[]> => {
  const derkapsWithPhotosPromises: Promise<TDerkapDB>[] = derkaps.map(
    async (derkap: Omit<TDerkapDB, "base64img">) => {
      const filePath = derkap.file_path;
      const key = `photo_${derkap.id}`;

      const cached_photo = await AsyncStorage.getItem(key);
      if (cached_photo) {
        return {
          ...derkap,
          base64img: cached_photo,
        };
      }

      const { data: file, error: errorDownload } = await supabase.storage
        .from(DERKAP_PHOTOS_BUCKET_NAME)
        .download(filePath);
      if (errorDownload) {
        throw new Error(errorDownload.message);
      }

      const encryptionKey = await getEncryptionKey({
        derkap_id: derkap.id,
      });

      const decryptedPost = await decryptPhoto({
        encryptedBlob: file,
        encryptionKey,
      });

      const photo = `data:image/jpeg;base64,${decryptedPost}`;

      await AsyncStorage.setItem(key, photo);

      return {
        ...derkap,
        base64img: photo,
      };
    },
  );

  const derkapsWithPhotos = await Promise.all(derkapsWithPhotosPromises);

  return derkapsWithPhotos;
};

export const fetchAllMyChallenges = async (): Promise<string[]> => {
  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }

  const CHUNK_SIZE = 100;
  const challenges: string[] = [];
  let hasMore = true;
  let offset = 0;

  while (hasMore) {
    const { data, error } = await supabase
      .from("derkap")
      .select("challenge")
      .eq("creator_id", user_id)
      .order("created_at", { ascending: false })
      .range(offset, offset + CHUNK_SIZE - 1);

    if (error) {
      throw new Error(error.message);
    }

    challenges.push(...data.map((derkap) => derkap.challenge));

    if (data.length < CHUNK_SIZE) {
      hasMore = false;
    }

    offset += CHUNK_SIZE;
  }

  return challenges;
};

export const removeAllowedUser = async ({
  derkap_id,
  allowed_user_id,
}: {
  derkap_id: number;
  allowed_user_id: string;
}) => {
  const { data, error } = await supabase
    .from("derkap_allowed_users")
    .delete()
    .eq("derkap_id", derkap_id)
    .eq("allowed_user_id", allowed_user_id);

  if (error) {
    throw new Error(error.message);
  }
};

export const fetchAllowedUsers = async ({
  derkap_id,
}: {
  derkap_id: number;
}): Promise<TProfileDB[]> => {
  const { data, error } = await supabase
    .from("derkap_allowed_users")
    .select("*, profile(*)")
    .eq("derkap_id", derkap_id);

  if (error) {
    throw new Error(error.message);
  }

  return data.map((derkap) => derkap.profile);
};

export const addAllowedUser = async ({
  derkap_id,
  allowed_user_id,
}: {
  derkap_id: number;
  allowed_user_id: string;
}) => {
  const { data, error } = await supabase
    .from("derkap_allowed_users")
    .insert({ derkap_id, allowed_user_id });

  if (error) {
    throw new Error(error.message);
  }
};

export const deleteDerkap = async ({ derkap_id }: { derkap_id: number }) => {
  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }
  const { error } = await supabase
    .from("derkap")
    .delete()
    .eq("id", derkap_id)
    .eq("creator_id", user_id);
  if (error) {
    throw new Error(error.message);
  }
};

export const fetchAllowedChallenges = async ({
  page = 1,
}: {
  page?: number;
} = {}): Promise<{ challenges: string[]; hasMore: boolean }> => {
  const RESULT_PER_PAGE = 50;

  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }

  // Calculate pagination offset
  const offset = (page - 1) * RESULT_PER_PAGE;

  // Get unique challenges from derkaps the user is allowed to see
  // We use a raw SQL query to get distinct challenges with proper ordering
  const { data, error } = await supabase.rpc("get_user_allowed_challenges", {
    p_user_id: user_id,
    p_limit: RESULT_PER_PAGE,
    p_offset: offset,
  });

  if (error) {
    console.error("Error fetching allowed challenges:", error);
    throw new Error(error.message);
  }

  const challenges =
    data?.map((item: { challenge: string }) => item.challenge) || [];
  const hasMore = challenges.length === RESULT_PER_PAGE;

  return { challenges, hasMore };
};

export const fetchDerkapsByChallenge = async ({
  challenge,
  page,
}: {
  challenge: string;
  page: number;
}): Promise<TDerkapDB[]> => {
  const RESULT_PER_PAGE = 6;

  const user = await supabase.auth.getUser();
  const user_id = user.data.user?.id;
  if (!user || !user_id) {
    throw new Error("Not authorized");
  }

  // Calculate pagination offset
  const offset = (page - 1) * RESULT_PER_PAGE;
  // Use RPC function for efficient querying with proper filtering and pagination
  const { data, error } = await supabase.rpc("get_user_derkaps_by_challenge", {
    p_user_id: user_id,
    p_challenge: challenge,
    p_limit: RESULT_PER_PAGE,
    p_offset: offset,
  });

  if (error) {
    console.error("Error fetching derkaps by challenge:", error);
    throw new Error(error.message);
  }

  if (!data || data.length === 0) {
    return [];
  }

  // Transform the RPC response to match the expected format
  const derkapsWithoutPhotos = data.map((item: any) => ({
    id: item.id,
    created_at: item.created_at,
    challenge: item.challenge,
    caption: item.caption,
    file_path: item.file_path,
    base_key: item.base_key,
    creator_id: item.creator_id,
    creator: {
      id: item.creator_id,
      username: item.creator_username,
      avatar_url: item.creator_avatar_url,
      email: item.creator_email,
      created_at: item.created_at,
    },
    derkap_allowed_users: item.allowed_users || [],
  }));

  const derkapsWithPhotos = await addPhotosToDerkaps({
    derkaps: derkapsWithoutPhotos,
  });

  return derkapsWithPhotos;
};
