create sequence "public"."app_version_id_seq";

create table "public"."app_ maintenance" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "maintenance_active" boolean not null default false
);


alter table "public"."app_ maintenance" enable row level security;

create table "public"."app_version" (
    "id" integer not null default nextval('app_version_id_seq'::regclass),
    "version" text not null,
    "min_supported_version" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "notes" text
);


alter table "public"."app_version" enable row level security;

create table "public"."comment" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "creator_id" uuid,
    "post_id" bigint,
    "content" text
);


alter table "public"."comment" enable row level security;

alter table "public"."group" add column "last_activity" timestamp with time zone default now();

alter sequence "public"."app_version_id_seq" owned by "public"."app_version"."id";

CREATE UNIQUE INDEX "app_ maintenance_pkey" ON public."app_ maintenance" USING btree (id);

CREATE UNIQUE INDEX app_version_pkey ON public.app_version USING btree (id);

CREATE UNIQUE INDEX comment_pkey ON public.comment USING btree (id);

alter table "public"."app_ maintenance" add constraint "app_ maintenance_pkey" PRIMARY KEY using index "app_ maintenance_pkey";

alter table "public"."app_version" add constraint "app_version_pkey" PRIMARY KEY using index "app_version_pkey";

alter table "public"."comment" add constraint "comment_pkey" PRIMARY KEY using index "comment_pkey";

alter table "public"."comment" add constraint "comment_creator_id_fkey" FOREIGN KEY (creator_id) REFERENCES profile(id) not valid;

alter table "public"."comment" validate constraint "comment_creator_id_fkey";

alter table "public"."comment" add constraint "comment_post_id_fkey" FOREIGN KEY (post_id) REFERENCES post(id) not valid;

alter table "public"."comment" validate constraint "comment_post_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_group_ranking(group_id_param bigint)
 RETURNS TABLE(rank integer, profile_id uuid, username text, avatar_url text, winned_challenges integer)
 LANGUAGE sql
 STABLE
AS $function$
with challenge_winners as (
  -- Find the winners for each challenge
  select
    p.profile_id,
    v.challenge_id
  from vote v
  join post p on v.post_id = p.id
  where p.challenge_id = v.challenge_id
  group by v.challenge_id, p.profile_id
  having count(v.id) = (
    -- Select the max votes received in each challenge
    select max(vote_count)
    from (
      select p.profile_id, v.challenge_id, count(v.id) as vote_count
      from vote v
      join post p on v.post_id = p.id
      where p.challenge_id = v.challenge_id
      group by p.profile_id, v.challenge_id
    ) as max_votes
    where max_votes.challenge_id = v.challenge_id
  )
),
user_wins as (
  -- Count the number of challenges won per user
  select profile_id, count(challenge_id) as winned_challenges
  from challenge_winners
  group by profile_id
),
group_users as (
  -- Get all users in the group
  select gp.profile_id, pr.username, pr.avatar_url
  from group_profile gp
  join profile pr on gp.profile_id = pr.id
  where gp.group_id = group_id_param
)
-- Generate the final ranking table
select 
  row_number() over (order by coalesce(uw.winned_challenges, 0) desc) as rank,
  gu.profile_id,
  gu.username,
  gu.avatar_url,
  coalesce(uw.winned_challenges, 0) as winned_challenges
from group_users gu
left join user_wins uw on gu.profile_id = uw.profile_id
order by winned_challenges desc;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_challenge_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = new.group_id;
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_comment_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = (
    select group_id 
    from challenge 
    where id = (
      select challenge_id 
      from post 
      where id = new.post_id
    )
  );
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_group_profile_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = coalesce(new.group_id, old.group_id);
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_group_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.last_activity = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_post_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = (
    select group_id from challenge where id = coalesce(new.challenge_id, old.challenge_id)
  );
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_vote_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = (
    select group_id 
    from challenge 
    where id = new.challenge_id
  );
  return null;
end;
$function$
;

grant delete on table "public"."app_ maintenance" to "anon";

grant insert on table "public"."app_ maintenance" to "anon";

grant references on table "public"."app_ maintenance" to "anon";

grant select on table "public"."app_ maintenance" to "anon";

grant trigger on table "public"."app_ maintenance" to "anon";

grant truncate on table "public"."app_ maintenance" to "anon";

grant update on table "public"."app_ maintenance" to "anon";

grant delete on table "public"."app_ maintenance" to "authenticated";

grant insert on table "public"."app_ maintenance" to "authenticated";

grant references on table "public"."app_ maintenance" to "authenticated";

grant select on table "public"."app_ maintenance" to "authenticated";

grant trigger on table "public"."app_ maintenance" to "authenticated";

grant truncate on table "public"."app_ maintenance" to "authenticated";

grant update on table "public"."app_ maintenance" to "authenticated";

grant delete on table "public"."app_ maintenance" to "service_role";

grant insert on table "public"."app_ maintenance" to "service_role";

grant references on table "public"."app_ maintenance" to "service_role";

grant select on table "public"."app_ maintenance" to "service_role";

grant trigger on table "public"."app_ maintenance" to "service_role";

grant truncate on table "public"."app_ maintenance" to "service_role";

grant update on table "public"."app_ maintenance" to "service_role";

grant delete on table "public"."app_version" to "anon";

grant insert on table "public"."app_version" to "anon";

grant references on table "public"."app_version" to "anon";

grant select on table "public"."app_version" to "anon";

grant trigger on table "public"."app_version" to "anon";

grant truncate on table "public"."app_version" to "anon";

grant update on table "public"."app_version" to "anon";

grant delete on table "public"."app_version" to "authenticated";

grant insert on table "public"."app_version" to "authenticated";

grant references on table "public"."app_version" to "authenticated";

grant select on table "public"."app_version" to "authenticated";

grant trigger on table "public"."app_version" to "authenticated";

grant truncate on table "public"."app_version" to "authenticated";

grant update on table "public"."app_version" to "authenticated";

grant delete on table "public"."app_version" to "service_role";

grant insert on table "public"."app_version" to "service_role";

grant references on table "public"."app_version" to "service_role";

grant select on table "public"."app_version" to "service_role";

grant trigger on table "public"."app_version" to "service_role";

grant truncate on table "public"."app_version" to "service_role";

grant update on table "public"."app_version" to "service_role";

grant delete on table "public"."comment" to "anon";

grant insert on table "public"."comment" to "anon";

grant references on table "public"."comment" to "anon";

grant select on table "public"."comment" to "anon";

grant trigger on table "public"."comment" to "anon";

grant truncate on table "public"."comment" to "anon";

grant update on table "public"."comment" to "anon";

grant delete on table "public"."comment" to "authenticated";

grant insert on table "public"."comment" to "authenticated";

grant references on table "public"."comment" to "authenticated";

grant select on table "public"."comment" to "authenticated";

grant trigger on table "public"."comment" to "authenticated";

grant truncate on table "public"."comment" to "authenticated";

grant update on table "public"."comment" to "authenticated";

grant delete on table "public"."comment" to "service_role";

grant insert on table "public"."comment" to "service_role";

grant references on table "public"."comment" to "service_role";

grant select on table "public"."comment" to "service_role";

grant trigger on table "public"."comment" to "service_role";

grant truncate on table "public"."comment" to "service_role";

grant update on table "public"."comment" to "service_role";

create policy "Everyone can get"
on "public"."app_ maintenance"
as permissive
for select
to public
using (true);


create policy "Public can read app version"
on "public"."app_version"
as permissive
for select
to public
using (true);


create policy "insert_comment_if_group_member"
on "public"."comment"
as permissive
for insert
to public
with check ((EXISTS ( SELECT 1
   FROM ((group_profile gp
     JOIN challenge c ON ((c.group_id = gp.group_id)))
     JOIN post p ON ((p.challenge_id = c.id)))
  WHERE ((gp.profile_id = auth.uid()) AND (p.id = comment.post_id)))));


create policy "select_comment_if_group_member"
on "public"."comment"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM ((group_profile gp
     JOIN challenge c ON ((c.group_id = gp.group_id)))
     JOIN post p ON ((p.challenge_id = c.id)))
  WHERE ((gp.profile_id = auth.uid()) AND (p.id = comment.post_id)))));


create policy "update_delete_own_comment"
on "public"."comment"
as permissive
for all
to public
using ((creator_id = auth.uid()));


CREATE TRIGGER trigger_last_activity_on_challenge_insert AFTER INSERT ON public.challenge FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_challenge_change();

CREATE TRIGGER trigger_last_activity_on_challenge_update AFTER UPDATE ON public.challenge FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_challenge_change();

CREATE TRIGGER trigger_last_activity_on_comment_insert AFTER INSERT ON public.comment FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_comment_insert();

CREATE TRIGGER trigger_last_activity_on_group_update BEFORE UPDATE ON public."group" FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_group_update();

CREATE TRIGGER trigger_last_activity_on_group_profile_delete AFTER DELETE ON public.group_profile FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_group_profile_change();

CREATE TRIGGER trigger_last_activity_on_group_profile_insert AFTER INSERT ON public.group_profile FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_group_profile_change();

CREATE TRIGGER trigger_last_activity_on_post_delete AFTER DELETE ON public.post FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_post_change();

CREATE TRIGGER trigger_last_activity_on_post_insert AFTER INSERT ON public.post FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_post_change();

CREATE TRIGGER trigger_last_activity_on_post_update AFTER UPDATE ON public.post FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_post_change();

CREATE TRIGGER trigger_last_activity_on_vote_insert AFTER INSERT ON public.vote FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_vote_change();

CREATE TRIGGER trigger_last_activity_on_vote_update AFTER UPDATE ON public.vote FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_vote_change();


