create table "public"."derkap" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "challenge" text,
    "creator_id" uuid,
    "caption" text,
    "file_path" text,
    "base_key" text
);


create table "public"."derkap_allowed_users" (
    "derkap_id" bigint not null,
    "allowed_user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


CREATE UNIQUE INDEX derkap_permissions_pkey ON public.derkap_allowed_users USING btree (derkap_id, allowed_user_id);

CREATE UNIQUE INDEX derkap_pkey ON public.derkap USING btree (id);

alter table "public"."derkap" add constraint "derkap_pkey" PRIMARY KEY using index "derkap_pkey";

alter table "public"."derkap_allowed_users" add constraint "derkap_permissions_pkey" PRIMARY KEY using index "derkap_permissions_pkey";

alter table "public"."derkap" add constraint "derkap_creator_id_fkey" FOREIGN KEY (creator_id) REFERENCES profile(id) not valid;

alter table "public"."derkap" validate constraint "derkap_creator_id_fkey";

alter table "public"."derkap_allowed_users" add constraint "derkap_allowed_users_derkap_id_fkey" FOREIGN KEY (derkap_id) REFERENCES derkap(id) ON DELETE CASCADE not valid;

alter table "public"."derkap_allowed_users" validate constraint "derkap_allowed_users_derkap_id_fkey";

alter table "public"."derkap_allowed_users" add constraint "fk_user" FOREIGN KEY (allowed_user_id) REFERENCES profile(id) ON DELETE CASCADE not valid;

alter table "public"."derkap_allowed_users" validate constraint "fk_user";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.insert_derkap_with_users(p_challenge text, p_caption text, p_allowed_users uuid[], p_base_key text, p_file_path text, p_user_id uuid)
 RETURNS TABLE(derkap_id bigint)
 LANGUAGE plpgsql
AS $function$
declare
    v_derkap_id bigint;
begin
    -- Insert into the 'derkap' table
    insert into public.derkap(challenge, creator_id, file_path, caption, base_key)
    values (p_challenge, p_user_id, p_file_path, p_caption, p_base_key)
    returning id into v_derkap_id;

    -- Insert allowed users into 'derkap_allowed_users' table
    insert into public.derkap_allowed_users(derkap_id, allowed_user_id)
    select v_derkap_id, unnest(p_allowed_users);

    -- Return the inserted derkap ID
    return query select v_derkap_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_derkap_with_users(p_challenge text, p_encrypted_post bytea, p_caption text, p_allowed_users uuid[], p_base_key text, p_file_path text, p_user_id uuid)
 RETURNS TABLE(derkap_id bigint)
 LANGUAGE plpgsql
AS $function$
declare
    v_derkap_id bigint;
begin
    -- Insert into the 'derkap' table
    insert into public.derkap(challenge, creator_id, file_path, caption, base_key)
    values (p_challenge, p_user_id, p_file_path, p_caption, p_base_key)
    returning id into v_derkap_id;

    -- Insert allowed users into 'derkap_allowed_users' table
    insert into public.derkap_allowed_users(derkap_id, allowed_user_id)
    select v_derkap_id, unnest(p_allowed_users);

    -- Return the inserted derkap ID
    return query select v_derkap_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_group_ranking(group_id_param bigint)
 RETURNS TABLE(rank integer, profile_id uuid, username text, avatar_url text, winned_challenges integer)
 LANGUAGE sql
 STABLE
AS $function$
WITH challenge_winners AS (
  -- Find the winners for each challenge in the specified group with status "ended"
  SELECT
    p.profile_id,
    v.challenge_id
  FROM vote v
  JOIN post p ON v.post_id = p.id
  JOIN challenge c ON v.challenge_id = c.id  -- Ensure challenge belongs to the group
  WHERE c.group_id = group_id_param  -- ✅ Only count challenges in this group
    AND c.status = 'ended'  -- ✅ Only consider challenges that are "ended"
  GROUP BY v.challenge_id, p.profile_id
  HAVING COUNT(v.id) = (
    -- Select the max votes received in each challenge
    SELECT MAX(vote_count)
    FROM (
      SELECT p.profile_id, v.challenge_id, COUNT(v.id) AS vote_count
      FROM vote v
      JOIN post p ON v.post_id = p.id
      JOIN challenge c ON v.challenge_id = c.id  -- Ensure challenge belongs to the group
      WHERE p.challenge_id = v.challenge_id
        AND c.status = 'ended'  -- ✅ Only count votes from ended challenges
      GROUP BY p.profile_id, v.challenge_id
    ) AS max_votes
    WHERE max_votes.challenge_id = v.challenge_id
  )
),
user_wins AS (
  -- Count the number of challenges won per user (only in this group)
  SELECT profile_id, COUNT(challenge_id) AS winned_challenges
  FROM challenge_winners
  GROUP BY profile_id
),
group_users AS (
  -- Get all users in the specified group
  SELECT gp.profile_id, pr.username, pr.avatar_url
  FROM group_profile gp
  JOIN profile pr ON gp.profile_id = pr.id
  WHERE gp.group_id = group_id_param
)
-- Generate the final ranking table
SELECT 
  ROW_NUMBER() OVER (ORDER BY COALESCE(uw.winned_challenges, 0) DESC) AS rank,
  gu.profile_id,
  gu.username,
  gu.avatar_url,
  COALESCE(uw.winned_challenges, 0) AS winned_challenges
FROM group_users gu
LEFT JOIN user_wins uw ON gu.profile_id = uw.profile_id
ORDER BY winned_challenges DESC;
$function$
;


