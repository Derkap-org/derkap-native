drop trigger if exists "trigger_last_activity_on_comment_insert" on "public"."comment";

drop trigger if exists "trigger_notify_new_comment" on "public"."comment";

drop policy "insert_comment_if_group_member" on "public"."comment";

drop policy "select_comment_if_group_member" on "public"."comment";

drop policy "update_delete_own_comment" on "public"."comment";

alter table "public"."comment" drop constraint "comment_post_id_fkey";

drop function if exists "public"."notify_new_comment"();

drop function if exists "public"."update_last_activity_on_comment_insert"();

create table "public"."derkap" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "challenge" text,
    "creator_id" uuid,
    "caption" text,
    "file_path" text,
    "base_key" text
);


alter table "public"."derkap" enable row level security;

create table "public"."derkap_allowed_users" (
    "derkap_id" bigint not null,
    "allowed_user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."derkap_allowed_users" enable row level security;

alter table "public"."comment" drop column "post_id";

alter table "public"."comment" add column "derkap_id" bigint;

CREATE UNIQUE INDEX derkap_permissions_pkey ON public.derkap_allowed_users USING btree (derkap_id, allowed_user_id);

CREATE UNIQUE INDEX derkap_pkey ON public.derkap USING btree (id);

alter table "public"."derkap" add constraint "derkap_pkey" PRIMARY KEY using index "derkap_pkey";

alter table "public"."derkap_allowed_users" add constraint "derkap_permissions_pkey" PRIMARY KEY using index "derkap_permissions_pkey";

alter table "public"."comment" add constraint "comment_derkap_id_fkey" FOREIGN KEY (derkap_id) REFERENCES derkap(id) not valid;

alter table "public"."comment" validate constraint "comment_derkap_id_fkey";

alter table "public"."derkap" add constraint "derkap_creator_id_fkey" FOREIGN KEY (creator_id) REFERENCES profile(id) not valid;

alter table "public"."derkap" validate constraint "derkap_creator_id_fkey";

alter table "public"."derkap_allowed_users" add constraint "derkap_allowed_users_derkap_id_fkey" FOREIGN KEY (derkap_id) REFERENCES derkap(id) ON DELETE CASCADE not valid;

alter table "public"."derkap_allowed_users" validate constraint "derkap_allowed_users_derkap_id_fkey";

alter table "public"."derkap_allowed_users" add constraint "fk_user" FOREIGN KEY (allowed_user_id) REFERENCES profile(id) ON DELETE CASCADE not valid;

alter table "public"."derkap_allowed_users" validate constraint "fk_user";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.insert_derkap_with_users(p_challenge text, p_caption text, p_allowed_users uuid[], p_base_key text, p_file_path text, p_user_id uuid)
 RETURNS TABLE(derkap_id bigint)
 LANGUAGE plpgsql
AS $function$
declare
    v_derkap_id bigint;
begin
    -- Insert into the 'derkap' table
    insert into public.derkap(challenge, creator_id, file_path, caption, base_key)
    values (p_challenge, p_user_id, p_file_path, p_caption, p_base_key)
    returning id into v_derkap_id;

    -- Insert allowed users into 'derkap_allowed_users' table
    insert into public.derkap_allowed_users(derkap_id, allowed_user_id)
    select v_derkap_id, unnest(p_allowed_users);

    -- Return the inserted derkap ID
    return query select v_derkap_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_derkap_with_users(p_challenge text, p_encrypted_post bytea, p_caption text, p_allowed_users uuid[], p_base_key text, p_file_path text, p_user_id uuid)
 RETURNS TABLE(derkap_id bigint)
 LANGUAGE plpgsql
AS $function$
declare
    v_derkap_id bigint;
begin
    -- Insert into the 'derkap' table
    insert into public.derkap(challenge, creator_id, file_path, caption, base_key)
    values (p_challenge, p_user_id, p_file_path, p_caption, p_base_key)
    returning id into v_derkap_id;

    -- Insert allowed users into 'derkap_allowed_users' table
    insert into public.derkap_allowed_users(derkap_id, allowed_user_id)
    select v_derkap_id, unnest(p_allowed_users);

    -- Return the inserted derkap ID
    return query select v_derkap_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.is_derkap_accessible(target_derkap_id bigint, requesting_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    -- Check if the user is the creator
    SELECT 1
    FROM public.derkap
    WHERE id = target_derkap_id AND creator_id = requesting_user_id
  ) OR EXISTS (
    -- Check if the user is in the allowed list
    SELECT 1
    FROM public.derkap_allowed_users
    WHERE derkap_id = target_derkap_id AND allowed_user_id = requesting_user_id
  );
$function$
;

CREATE OR REPLACE FUNCTION public.get_group_ranking(group_id_param bigint)
 RETURNS TABLE(rank integer, profile_id uuid, username text, avatar_url text, winned_challenges integer)
 LANGUAGE sql
 STABLE
AS $function$
WITH challenge_winners AS (
  -- Find the winners for each challenge in the specified group with status "ended"
  SELECT
    p.profile_id,
    v.challenge_id
  FROM vote v
  JOIN post p ON v.post_id = p.id
  JOIN challenge c ON v.challenge_id = c.id  -- Ensure challenge belongs to the group
  WHERE c.group_id = group_id_param  -- ✅ Only count challenges in this group
    AND c.status = 'ended'  -- ✅ Only consider challenges that are "ended"
  GROUP BY v.challenge_id, p.profile_id
  HAVING COUNT(v.id) = (
    -- Select the max votes received in each challenge
    SELECT MAX(vote_count)
    FROM (
      SELECT p.profile_id, v.challenge_id, COUNT(v.id) AS vote_count
      FROM vote v
      JOIN post p ON v.post_id = p.id
      JOIN challenge c ON v.challenge_id = c.id  -- Ensure challenge belongs to the group
      WHERE p.challenge_id = v.challenge_id
        AND c.status = 'ended'  -- ✅ Only count votes from ended challenges
      GROUP BY p.profile_id, v.challenge_id
    ) AS max_votes
    WHERE max_votes.challenge_id = v.challenge_id
  )
),
user_wins AS (
  -- Count the number of challenges won per user (only in this group)
  SELECT profile_id, COUNT(challenge_id) AS winned_challenges
  FROM challenge_winners
  GROUP BY profile_id
),
group_users AS (
  -- Get all users in the specified group
  SELECT gp.profile_id, pr.username, pr.avatar_url
  FROM group_profile gp
  JOIN profile pr ON gp.profile_id = pr.id
  WHERE gp.group_id = group_id_param
)
-- Generate the final ranking table
SELECT 
  ROW_NUMBER() OVER (ORDER BY COALESCE(uw.winned_challenges, 0) DESC) AS rank,
  gu.profile_id,
  gu.username,
  gu.avatar_url,
  COALESCE(uw.winned_challenges, 0) AS winned_challenges
FROM group_users gu
LEFT JOIN user_wins uw ON gu.profile_id = uw.profile_id
ORDER BY winned_challenges DESC;
$function$
;

grant delete on table "public"."derkap" to "anon";

grant insert on table "public"."derkap" to "anon";

grant references on table "public"."derkap" to "anon";

grant select on table "public"."derkap" to "anon";

grant trigger on table "public"."derkap" to "anon";

grant truncate on table "public"."derkap" to "anon";

grant update on table "public"."derkap" to "anon";

grant delete on table "public"."derkap" to "authenticated";

grant insert on table "public"."derkap" to "authenticated";

grant references on table "public"."derkap" to "authenticated";

grant select on table "public"."derkap" to "authenticated";

grant trigger on table "public"."derkap" to "authenticated";

grant truncate on table "public"."derkap" to "authenticated";

grant update on table "public"."derkap" to "authenticated";

grant delete on table "public"."derkap" to "service_role";

grant insert on table "public"."derkap" to "service_role";

grant references on table "public"."derkap" to "service_role";

grant select on table "public"."derkap" to "service_role";

grant trigger on table "public"."derkap" to "service_role";

grant truncate on table "public"."derkap" to "service_role";

grant update on table "public"."derkap" to "service_role";

grant delete on table "public"."derkap_allowed_users" to "anon";

grant insert on table "public"."derkap_allowed_users" to "anon";

grant references on table "public"."derkap_allowed_users" to "anon";

grant select on table "public"."derkap_allowed_users" to "anon";

grant trigger on table "public"."derkap_allowed_users" to "anon";

grant truncate on table "public"."derkap_allowed_users" to "anon";

grant update on table "public"."derkap_allowed_users" to "anon";

grant delete on table "public"."derkap_allowed_users" to "authenticated";

grant insert on table "public"."derkap_allowed_users" to "authenticated";

grant references on table "public"."derkap_allowed_users" to "authenticated";

grant select on table "public"."derkap_allowed_users" to "authenticated";

grant trigger on table "public"."derkap_allowed_users" to "authenticated";

grant truncate on table "public"."derkap_allowed_users" to "authenticated";

grant update on table "public"."derkap_allowed_users" to "authenticated";

grant delete on table "public"."derkap_allowed_users" to "service_role";

grant insert on table "public"."derkap_allowed_users" to "service_role";

grant references on table "public"."derkap_allowed_users" to "service_role";

grant select on table "public"."derkap_allowed_users" to "service_role";

grant trigger on table "public"."derkap_allowed_users" to "service_role";

grant truncate on table "public"."derkap_allowed_users" to "service_role";

grant update on table "public"."derkap_allowed_users" to "service_role";

create policy "Allow comment delete for creator"
on "public"."comment"
as permissive
for delete
to public
using ((creator_id = auth.uid()));


create policy "Allow comment update for creator"
on "public"."comment"
as permissive
for update
to public
using ((creator_id = auth.uid()));


create policy "Allow commenting if allowed user"
on "public"."comment"
as permissive
for insert
to public
with check (((EXISTS ( SELECT 1
   FROM derkap_allowed_users dau
  WHERE ((dau.derkap_id = comment.derkap_id) AND (dau.allowed_user_id = auth.uid())))) AND (creator_id = auth.uid())));


create policy "Allow reading comments if allowed user"
on "public"."comment"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM derkap_allowed_users dau
  WHERE ((dau.derkap_id = comment.derkap_id) AND (dau.allowed_user_id = auth.uid())))));


create policy "Allow creator to view their own derkap"
on "public"."derkap"
as permissive
for select
to public
using ((creator_id = auth.uid()));


create policy "Allow delete for creator"
on "public"."derkap"
as permissive
for delete
to public
using ((creator_id = auth.uid()));


create policy "Allow insert for creator"
on "public"."derkap"
as permissive
for insert
to public
with check ((creator_id = auth.uid()));


create policy "Allow update for creator"
on "public"."derkap"
as permissive
for update
to public
using ((creator_id = auth.uid()));


create policy "Allow view for allowed users"
on "public"."derkap"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM derkap_allowed_users dau
  WHERE ((dau.derkap_id = derkap.id) AND (dau.allowed_user_id = auth.uid())))));


create policy "Allow creator to insert allowed users"
on "public"."derkap_allowed_users"
as permissive
for insert
to public
with check ((EXISTS ( SELECT 1
   FROM derkap d
  WHERE (d.creator_id = auth.uid()))));


create policy "Allow deleting allowed users if creator"
on "public"."derkap_allowed_users"
as permissive
for delete
to public
using ((EXISTS ( SELECT 1
   FROM derkap d
  WHERE (d.creator_id = auth.uid()))));


create policy "Allow updating allowed users if creator"
on "public"."derkap_allowed_users"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM derkap d
  WHERE (d.creator_id = auth.uid()))))
with check ((EXISTS ( SELECT 1
   FROM derkap d
  WHERE (d.creator_id = auth.uid()))));


create policy "Auth to get dau"
on "public"."derkap_allowed_users"
as permissive
for select
to authenticated
using (true);



