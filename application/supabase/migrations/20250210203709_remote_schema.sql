drop trigger if exists "auto_update_challenge_status_to_voting" on "public"."encrypted_post";

drop trigger if exists "trigger_notify_new_encrypted_post" on "public"."encrypted_post";

drop policy "Allow group member to read encrypted_posts" on "public"."encrypted_post";

drop policy "Allow group members to upsert posts" on "public"."encrypted_post";

revoke delete on table "public"."encrypted_post" from "anon";

revoke insert on table "public"."encrypted_post" from "anon";

revoke references on table "public"."encrypted_post" from "anon";

revoke select on table "public"."encrypted_post" from "anon";

revoke trigger on table "public"."encrypted_post" from "anon";

revoke truncate on table "public"."encrypted_post" from "anon";

revoke update on table "public"."encrypted_post" from "anon";

revoke delete on table "public"."encrypted_post" from "authenticated";

revoke insert on table "public"."encrypted_post" from "authenticated";

revoke references on table "public"."encrypted_post" from "authenticated";

revoke select on table "public"."encrypted_post" from "authenticated";

revoke trigger on table "public"."encrypted_post" from "authenticated";

revoke truncate on table "public"."encrypted_post" from "authenticated";

revoke update on table "public"."encrypted_post" from "authenticated";

revoke delete on table "public"."encrypted_post" from "service_role";

revoke insert on table "public"."encrypted_post" from "service_role";

revoke references on table "public"."encrypted_post" from "service_role";

revoke select on table "public"."encrypted_post" from "service_role";

revoke trigger on table "public"."encrypted_post" from "service_role";

revoke truncate on table "public"."encrypted_post" from "service_role";

revoke update on table "public"."encrypted_post" from "service_role";

alter table "public"."encrypted_post" drop constraint "encrypted_photo_challenge_id_fkey";

alter table "public"."encrypted_post" drop constraint "encrypted_photo_profile_id_fkey";

alter table "public"."encrypted_post" drop constraint "encrypted_photo_unique_challenge_profile";

alter table "public"."vote" drop constraint "vote_post_id_fkey";

alter table "public"."encrypted_post" drop constraint "encrypted_photo_pkey";

drop index if exists "public"."encrypted_photo_pkey";

drop index if exists "public"."encrypted_photo_unique_challenge_profile";

drop table "public"."encrypted_post";

create table "public"."post" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "file_path" text,
    "challenge_id" bigint,
    "profile_id" uuid
);


alter table "public"."post" enable row level security;

alter table "public"."challenge" add column "base_key" text;

CREATE UNIQUE INDEX post_challenge_id_profile_id_key ON public.post USING btree (challenge_id, profile_id);

CREATE UNIQUE INDEX post_pkey ON public.post USING btree (id);

alter table "public"."post" add constraint "post_pkey" PRIMARY KEY using index "post_pkey";

alter table "public"."post" add constraint "post_challenge_id_fkey" FOREIGN KEY (challenge_id) REFERENCES challenge(id) not valid;

alter table "public"."post" validate constraint "post_challenge_id_fkey";

alter table "public"."post" add constraint "post_challenge_id_profile_id_key" UNIQUE using index "post_challenge_id_profile_id_key";

alter table "public"."post" add constraint "post_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profile(id) not valid;

alter table "public"."post" validate constraint "post_profile_id_fkey";

alter table "public"."vote" add constraint "vote_post_id_fkey" FOREIGN KEY (post_id) REFERENCES post(id) not valid;

alter table "public"."vote" validate constraint "vote_post_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.notify_new_post()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM
    net.http_post(
      url := 'https://hrktxqpsqbjnockggnic.supabase.co/functions/v1/notify-new-post',
      headers := json_build_object(
        'Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhya3R4cXBzcWJqbm9ja2dnbmljIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcxNzc0ODMxOSwiZXhwIjoyMDMzMzI0MzE5fQ.eT0_E89SJcXMMxwiQBxr0IwIhASgms4BDNRVz3CZ_xc'
      )::jsonb,
      body := json_build_object(
        'post_id', NEW.id,
        'challenge_id', NEW.challenge_id,
        'sender_id', NEW.profile_id
      )::jsonb
    );

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_challenge_status_to_ended()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  challenge_group_id BIGINT;
  member_count INTEGER;
  vote_count INTEGER;
BEGIN
  -- Get the group ID of the challenge
  SELECT group_id INTO challenge_group_id
  FROM challenge
  WHERE id = NEW.challenge_id;

  -- Count the number of members in the group
  SELECT COUNT(*) INTO member_count
  FROM group_profile
  WHERE group_id = challenge_group_id;

  -- Count the number of votes for the specific challenge
  SELECT COUNT(DISTINCT user_id) INTO vote_count -- Count distinct users to avoid double counting
  FROM vote
  WHERE challenge_id = NEW.challenge_id;

  -- Check if everyone in the group has voted
  IF vote_count = member_count THEN
    -- Update the challenge status to 'ended'
    UPDATE challenge
    SET status = 'ended'
    WHERE id = NEW.challenge_id;
  END IF;

  RETURN NEW; -- Important: Return NEW for triggers on INSERT
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_challenge_status_to_voting()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Get the challenge and its associated group information
    WITH challenge_info AS (
        SELECT 
            c.id AS challenge_id,
            c.group_id,
            c.status,
            (
                SELECT COUNT(*)
                FROM group_profile gp
                WHERE gp.group_id = c.group_id
            ) AS total_members,
            (
                SELECT COUNT(DISTINCT p.profile_id)
                FROM post p
                WHERE p.challenge_id = c.id
            ) AS total_posts
        FROM challenge c
        WHERE c.id = NEW.challenge_id
    )
    UPDATE challenge c
    SET status = 'voting'
    FROM challenge_info ci
    WHERE c.id = ci.challenge_id
    AND ci.status != 'voting'  -- Only update if not already in voting status
    AND ci.total_posts = ci.total_members;  -- Update only when all members have posted

    RETURN NEW;
END;
$function$
;

grant delete on table "public"."post" to "anon";

grant insert on table "public"."post" to "anon";

grant references on table "public"."post" to "anon";

grant select on table "public"."post" to "anon";

grant trigger on table "public"."post" to "anon";

grant truncate on table "public"."post" to "anon";

grant update on table "public"."post" to "anon";

grant delete on table "public"."post" to "authenticated";

grant insert on table "public"."post" to "authenticated";

grant references on table "public"."post" to "authenticated";

grant select on table "public"."post" to "authenticated";

grant trigger on table "public"."post" to "authenticated";

grant truncate on table "public"."post" to "authenticated";

grant update on table "public"."post" to "authenticated";

grant delete on table "public"."post" to "service_role";

grant insert on table "public"."post" to "service_role";

grant references on table "public"."post" to "service_role";

grant select on table "public"."post" to "service_role";

grant trigger on table "public"."post" to "service_role";

grant truncate on table "public"."post" to "service_role";

grant update on table "public"."post" to "service_role";

create policy "Users can only insert their own posts if they are in the challe"
on "public"."post"
as permissive
for insert
to public
with check (((profile_id = auth.uid()) AND (challenge_id IN ( SELECT challenge.id
   FROM (challenge
     JOIN group_profile ON ((challenge.group_id = group_profile.group_id)))
  WHERE (group_profile.profile_id = auth.uid())))));


create policy "Users can view posts from challenges in their groups"
on "public"."post"
as permissive
for select
to public
using ((challenge_id IN ( SELECT challenge.id
   FROM (challenge
     JOIN group_profile ON ((challenge.group_id = group_profile.group_id)))
  WHERE (group_profile.profile_id = auth.uid()))));


CREATE TRIGGER auto_update_challenge_status_to_voting AFTER INSERT OR UPDATE ON public.post FOR EACH ROW EXECUTE FUNCTION update_challenge_status_to_voting();

CREATE TRIGGER trigger_notify_new_post AFTER INSERT ON public.post FOR EACH ROW EXECUTE FUNCTION notify_new_post();


