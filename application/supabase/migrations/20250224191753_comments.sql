drop policy "Enable update for users based on created_id" on "public"."challenge";

create table "public"."comment" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "creator_id" uuid,
    "post_id" bigint,
    "content" text
);


CREATE UNIQUE INDEX comment_pkey ON public.comment USING btree (id);

alter table "public"."comment" add constraint "comment_pkey" PRIMARY KEY using index "comment_pkey";

alter table "public"."comment" add constraint "comment_creator_id_fkey" FOREIGN KEY (creator_id) REFERENCES profile(id) not valid;

alter table "public"."comment" validate constraint "comment_creator_id_fkey";

alter table "public"."comment" add constraint "comment_post_id_fkey" FOREIGN KEY (post_id) REFERENCES post(id) not valid;

alter table "public"."comment" validate constraint "comment_post_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_group_ranking(group_id_param bigint)
 RETURNS TABLE(rank integer, profile_id uuid, username text, avatar_url text, winned_challenges integer)
 LANGUAGE sql
 STABLE
AS $function$
with challenge_winners as (
  -- Find the winners for each challenge
  select
    p.profile_id,
    v.challenge_id
  from vote v
  join post p on v.post_id = p.id
  where p.challenge_id = v.challenge_id
  group by v.challenge_id, p.profile_id
  having count(v.id) = (
    -- Select the max votes received in each challenge
    select max(vote_count)
    from (
      select p.profile_id, v.challenge_id, count(v.id) as vote_count
      from vote v
      join post p on v.post_id = p.id
      where p.challenge_id = v.challenge_id
      group by p.profile_id, v.challenge_id
    ) as max_votes
    where max_votes.challenge_id = v.challenge_id
  )
),
user_wins as (
  -- Count the number of challenges won per user
  select profile_id, count(challenge_id) as winned_challenges
  from challenge_winners
  group by profile_id
),
group_users as (
  -- Get all users in the group
  select gp.profile_id, pr.username, pr.avatar_url
  from group_profile gp
  join profile pr on gp.profile_id = pr.id
  where gp.group_id = group_id_param
)
-- Generate the final ranking table
select 
  row_number() over (order by coalesce(uw.winned_challenges, 0) desc) as rank,
  gu.profile_id,
  gu.username,
  gu.avatar_url,
  coalesce(uw.winned_challenges, 0) as winned_challenges
from group_users gu
left join user_wins uw on gu.profile_id = uw.profile_id
order by winned_challenges desc;
$function$
;

CREATE OR REPLACE FUNCTION public.update_challenge_status_to_ended()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  challenge_group_id BIGINT;
  member_count INTEGER;
  vote_count INTEGER;
  current_status text;
BEGIN
  -- Get the group ID and current status of the challenge
  SELECT c.group_id, c.status::text INTO challenge_group_id, current_status
  FROM challenge c
  WHERE c.id = NEW.challenge_id;

  -- Count the number of active members in the group
  SELECT COUNT(*) INTO member_count
  FROM group_profile gp
  WHERE gp.group_id = challenge_group_id
  AND gp.profile_id IS NOT NULL;

  -- Count the number of DISTINCT voters for this challenge
  SELECT COUNT(DISTINCT v.user_id) INTO vote_count
  FROM vote v
  WHERE v.challenge_id = NEW.challenge_id;

  -- If the vote count equals the member count, update the challenge status to 'ended'
  IF vote_count >= member_count THEN
    UPDATE challenge
    SET status = 'ended'::challenge_status
    WHERE id = NEW.challenge_id
    AND status = 'voting'::challenge_status;
    
  END IF;

  RETURN NEW;
END;
$function$
;

create policy "Enable update for users based on created_id"
on "public"."challenge"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = challenge.group_id) AND (gp.profile_id = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = challenge.group_id) AND (gp.profile_id = auth.uid())))));



