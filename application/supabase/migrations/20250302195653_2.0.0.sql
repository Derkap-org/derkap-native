create extension if not exists "http" with schema "extensions";


create type "public"."challenge_status" as enum ('posting', 'voting', 'ended');

create sequence "public"."app_version_id_seq";

create table "public"."app_ maintenance" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "maintenance_active" boolean not null default false
);


alter table "public"."app_ maintenance" enable row level security;

create table "public"."app_version" (
    "id" integer not null default nextval('app_version_id_seq'::regclass),
    "version" text not null,
    "min_supported_version" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "notes" text
);


alter table "public"."app_version" enable row level security;

create table "public"."challenge" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "description" text not null,
    "creator_id" uuid,
    "group_id" bigint not null,
    "status" challenge_status not null,
    "base_key" text
);


alter table "public"."challenge" enable row level security;

create table "public"."comment" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "creator_id" uuid,
    "post_id" bigint,
    "content" text
);


alter table "public"."comment" enable row level security;

create table "public"."group" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "img_url" text,
    "invite_code" text default ''::text,
    "creator_id" uuid default auth.uid(),
    "last_activity" timestamp with time zone default now()
);


alter table "public"."group" enable row level security;

create table "public"."group_profile" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "profile_id" uuid,
    "group_id" bigint not null
);


alter table "public"."group_profile" enable row level security;

create table "public"."notification_subscription" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "updated_at" timestamp with time zone default now(),
    "expo_push_token" text
);


alter table "public"."notification_subscription" enable row level security;

create table "public"."post" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "file_path" text,
    "challenge_id" bigint,
    "profile_id" uuid,
    "caption" text
);


alter table "public"."post" enable row level security;

create table "public"."profile" (
    "id" uuid not null,
    "username" text not null,
    "avatar_url" text,
    "created_at" timestamp with time zone not null default now(),
    "email" text not null
);


alter table "public"."profile" enable row level security;

create table "public"."vote" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "post_id" bigint not null,
    "challenge_id" bigint not null
);


alter table "public"."vote" enable row level security;

alter sequence "public"."app_version_id_seq" owned by "public"."app_version"."id";

CREATE UNIQUE INDEX "app_ maintenance_pkey" ON public."app_ maintenance" USING btree (id);

CREATE UNIQUE INDEX app_version_pkey ON public.app_version USING btree (id);

CREATE UNIQUE INDEX challenge_pkey ON public.challenge USING btree (id);

CREATE UNIQUE INDEX comment_pkey ON public.comment USING btree (id);

CREATE UNIQUE INDEX group_profile_pkey ON public.group_profile USING btree (id);

CREATE UNIQUE INDEX groupe_invite_code_key ON public."group" USING btree (invite_code);

CREATE UNIQUE INDEX groupe_pkey ON public."group" USING btree (id);

CREATE UNIQUE INDEX notification_subscription_pkey ON public.notification_subscription USING btree (id);

CREATE UNIQUE INDEX notification_subscription_user_id_key ON public.notification_subscription USING btree (user_id);

CREATE UNIQUE INDEX post_challenge_id_profile_id_key ON public.post USING btree (challenge_id, profile_id);

CREATE UNIQUE INDEX post_pkey ON public.post USING btree (id);

CREATE UNIQUE INDEX profile_pkey ON public.profile USING btree (id);

CREATE UNIQUE INDEX profile_username_key ON public.profile USING btree (username);

CREATE UNIQUE INDEX unique_user_challenge_vote ON public.vote USING btree (user_id, challenge_id);

CREATE UNIQUE INDEX vote_pkey ON public.vote USING btree (id);

alter table "public"."app_ maintenance" add constraint "app_ maintenance_pkey" PRIMARY KEY using index "app_ maintenance_pkey";

alter table "public"."app_version" add constraint "app_version_pkey" PRIMARY KEY using index "app_version_pkey";

alter table "public"."challenge" add constraint "challenge_pkey" PRIMARY KEY using index "challenge_pkey";

alter table "public"."comment" add constraint "comment_pkey" PRIMARY KEY using index "comment_pkey";

alter table "public"."group" add constraint "groupe_pkey" PRIMARY KEY using index "groupe_pkey";

alter table "public"."group_profile" add constraint "group_profile_pkey" PRIMARY KEY using index "group_profile_pkey";

alter table "public"."notification_subscription" add constraint "notification_subscription_pkey" PRIMARY KEY using index "notification_subscription_pkey";

alter table "public"."post" add constraint "post_pkey" PRIMARY KEY using index "post_pkey";

alter table "public"."profile" add constraint "profile_pkey" PRIMARY KEY using index "profile_pkey";

alter table "public"."vote" add constraint "vote_pkey" PRIMARY KEY using index "vote_pkey";

alter table "public"."challenge" add constraint "challenge_creator_id_fkey" FOREIGN KEY (creator_id) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."challenge" validate constraint "challenge_creator_id_fkey";

alter table "public"."challenge" add constraint "challenge_group_id_fkey" FOREIGN KEY (group_id) REFERENCES "group"(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."challenge" validate constraint "challenge_group_id_fkey";

alter table "public"."comment" add constraint "comment_creator_id_fkey" FOREIGN KEY (creator_id) REFERENCES profile(id) not valid;

alter table "public"."comment" validate constraint "comment_creator_id_fkey";

alter table "public"."comment" add constraint "comment_post_id_fkey" FOREIGN KEY (post_id) REFERENCES post(id) not valid;

alter table "public"."comment" validate constraint "comment_post_id_fkey";

alter table "public"."group" add constraint "group_creator_id_fkey" FOREIGN KEY (creator_id) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."group" validate constraint "group_creator_id_fkey";

alter table "public"."group" add constraint "groupe_invite_code_key" UNIQUE using index "groupe_invite_code_key";

alter table "public"."group_profile" add constraint "group_profile_group_id_fkey" FOREIGN KEY (group_id) REFERENCES "group"(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."group_profile" validate constraint "group_profile_group_id_fkey";

alter table "public"."group_profile" add constraint "group_profile_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."group_profile" validate constraint "group_profile_profile_id_fkey";

alter table "public"."notification_subscription" add constraint "notification_subscription_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."notification_subscription" validate constraint "notification_subscription_user_id_fkey";

alter table "public"."notification_subscription" add constraint "notification_subscription_user_id_key" UNIQUE using index "notification_subscription_user_id_key";

alter table "public"."post" add constraint "post_challenge_id_fkey" FOREIGN KEY (challenge_id) REFERENCES challenge(id) not valid;

alter table "public"."post" validate constraint "post_challenge_id_fkey";

alter table "public"."post" add constraint "post_challenge_id_profile_id_key" UNIQUE using index "post_challenge_id_profile_id_key";

alter table "public"."post" add constraint "post_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profile(id) not valid;

alter table "public"."post" validate constraint "post_profile_id_fkey";

alter table "public"."profile" add constraint "profile_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_id_fkey";

alter table "public"."profile" add constraint "profile_username_key" UNIQUE using index "profile_username_key";

alter table "public"."profile" add constraint "username_length" CHECK ((char_length(username) >= 3)) not valid;

alter table "public"."profile" validate constraint "username_length";

alter table "public"."vote" add constraint "unique_user_challenge_vote" UNIQUE using index "unique_user_challenge_vote";

alter table "public"."vote" add constraint "vote_challenge_id_fkey" FOREIGN KEY (challenge_id) REFERENCES challenge(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."vote" validate constraint "vote_challenge_id_fkey";

alter table "public"."vote" add constraint "vote_post_id_fkey" FOREIGN KEY (post_id) REFERENCES post(id) not valid;

alter table "public"."vote" validate constraint "vote_post_id_fkey";

alter table "public"."vote" add constraint "vote_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."vote" validate constraint "vote_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.cron_schedule()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    new_challenge RECORD;
BEGIN
    -- Désactiver le défi actuellement actif
    UPDATE challenge
    SET is_active = false
    WHERE is_active = true;

    -- Sélectionner un nouveau défi qui n'a pas encore été utilisé et l'activer
    UPDATE challenge
    SET is_active = true, 
        -- is_already_used = true,  
        date_used = CURRENT_DATE
    WHERE id = (
        SELECT id
        FROM challenge
        WHERE is_already_used = false
        ORDER BY RANDOM()
        LIMIT 1
    )
    RETURNING * INTO new_challenge;

    -- Appeler la fonction Edge avec les données du défi en utilisant PERFORM
    PERFORM http_post(
        'https://hrktxqpsqbjnockggnic.supabase.co/functions/v1/sendChallengeNotification',
        json_build_object('title', new_challenge.title, 'message', new_challenge.description)::text,
        'application/json'
    );

    -- Log optionnel pour déboguer
    RAISE NOTICE 'Notification sent for new challenge: %', new_challenge.title;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_unique_invite_code()
 RETURNS text
 LANGUAGE plpgsql
AS $function$DECLARE
    new_code TEXT;
    exists BOOLEAN;
BEGIN
    LOOP
        -- Generate a random 10-character alphanumeric code
        new_code := upper(substring(md5(random()::text) from 1 for 10));

        -- Check if the code already exists in the "groups" table
        SELECT EXISTS (SELECT 1 FROM public.group WHERE invite_code = new_code) INTO exists;

        -- If the code is unique, exit the loop
        IF NOT exists THEN
            EXIT;
        END IF;
    END LOOP;

    RETURN new_code;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_group_by_invite_code(p_invite_code text)
 RETURNS SETOF "group"
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- Return the group that matches the invite code
  -- The security definer allows this function to bypass RLS
  return query
  select *
  from "group"
  where "group".invite_code = p_invite_code
  limit 1;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_group_ranking(group_id_param bigint)
 RETURNS TABLE(rank integer, profile_id uuid, username text, avatar_url text, winned_challenges integer)
 LANGUAGE sql
 STABLE
AS $function$
with challenge_winners as (
  -- Find the winners for each challenge
  select
    p.profile_id,
    v.challenge_id
  from vote v
  join post p on v.post_id = p.id
  where p.challenge_id = v.challenge_id
  group by v.challenge_id, p.profile_id
  having count(v.id) = (
    -- Select the max votes received in each challenge
    select max(vote_count)
    from (
      select p.profile_id, v.challenge_id, count(v.id) as vote_count
      from vote v
      join post p on v.post_id = p.id
      where p.challenge_id = v.challenge_id
      group by p.profile_id, v.challenge_id
    ) as max_votes
    where max_votes.challenge_id = v.challenge_id
  )
),
user_wins as (
  -- Count the number of challenges won per user
  select profile_id, count(challenge_id) as winned_challenges
  from challenge_winners
  group by profile_id
),
group_users as (
  -- Get all users in the group
  select gp.profile_id, pr.username, pr.avatar_url
  from group_profile gp
  join profile pr on gp.profile_id = pr.id
  where gp.group_id = group_id_param
)
-- Generate the final ranking table
select 
  row_number() over (order by coalesce(uw.winned_challenges, 0) desc) as rank,
  gu.profile_id,
  gu.username,
  gu.avatar_url,
  coalesce(uw.winned_challenges, 0) as winned_challenges
from group_users gu
left join user_wins uw on gu.profile_id = uw.profile_id
order by winned_challenges desc;
$function$
;

CREATE OR REPLACE FUNCTION public.get_group_user_count(group_id_param bigint)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    user_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO user_count
    FROM group_profile
    WHERE group_id = group_id_param;
    
    RETURN user_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_latest_challenge_status(group_ids bigint[])
 RETURNS TABLE(group_id bigint, status challenge_status)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  WITH latest_challenges AS (
    SELECT 
      c.group_id,  -- Fully qualify the column
      c.status,
      ROW_NUMBER() OVER (PARTITION BY c.group_id ORDER BY c.created_at DESC) AS rn
    FROM 
      challenge c  -- Alias the table to avoid ambiguity
    WHERE 
      c.group_id = ANY(group_ids)
  )
  SELECT 
    lc.group_id,  -- Fully qualify the column
    lc.status
  FROM 
    latest_challenges lc  -- Alias the CTE to avoid ambiguity
  WHERE 
    lc.rn = 1;  -- Fully qualify the rn column
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  insert into public.profile (id,email,username)
  values (new.id, new.email, new.raw_user_meta_data->>'username');
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.notify_backend_of_new_challenge()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.is_active = true AND NEW.notification_sent = false THEN
        -- Appelle une fonction externe (que nous allons configurer dans Supabase) pour notifier le backend
        PERFORM pg_notify('new_challenge', json_build_object(
            'title', NEW.title, 
            'description', NEW.description
        )::text);

        -- Marque la notification comme envoyée
        NEW.notification_sent := true;
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_challenge_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Determine if this is a new challenge or a status update
  IF TG_OP = 'INSERT' THEN
    PERFORM
      net.http_post(
        url := 'https://hrktxqpsqbjnockggnic.supabase.co/functions/v1/notify-challenge-update',
        headers := json_build_object('Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhya3R4cXBzcWJqbm9ja2dnbmljIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcxNzc0ODMxOSwiZXhwIjoyMDMzMzI0MzE5fQ.eT0_E89SJcXMMxwiQBxr0IwIhASgms4BDNRVz3CZ_xc')::jsonb,
        body := json_build_object(
          'challenge_id', NEW.id,
          'group_id', NEW.group_id,
          'event_type', 'new_challenge',
          'new_status', NEW.status
        )::jsonb
      );
  ELSIF TG_OP = 'UPDATE' AND OLD.status <> NEW.status THEN
    PERFORM
      net.http_post(
        url := 'https://hrktxqpsqbjnockggnic.supabase.co/functions/v1/notify-challenge-update',
        headers := json_build_object('Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhya3R4cXBzcWJqbm9ja2dnbmljIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcxNzc0ODMxOSwiZXhwIjoyMDMzMzI0MzE5fQ.eT0_E89SJcXMMxwiQBxr0IwIhASgms4BDNRVz3CZ_xc')::jsonb,
        body := json_build_object(
          'challenge_id', NEW.id,
          'group_id', NEW.group_id,
          'event_type', 'status_change',
          'old_status', OLD.status,
          'new_status', NEW.status
        )::jsonb
      );
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_new_encrypted_post()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM
    net.http_post(
      url := 'https://hrktxqpsqbjnockggnic.supabase.co/functions/v1/notify-new-post',
      headers := json_build_object(
        'Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhya3R4cXBzcWJqbm9ja2dnbmljIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcxNzc0ODMxOSwiZXhwIjoyMDMzMzI0MzE5fQ.eT0_E89SJcXMMxwiQBxr0IwIhASgms4BDNRVz3CZ_xc'
      )::jsonb,
      body := json_build_object(
        'post_id', NEW.id,
        'challenge_id', NEW.challenge_id,
        'sender_id', NEW.profile_id
      )::jsonb
    );

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_new_group_member()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM net.http_post(
    url := 'https://hrktxqpsqbjnockggnic.supabase.co/functions/v1/notify-new-group-member',
    headers := json_build_object(
      'Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhya3R4cXBzcWJqbm9ja2dnbmljIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcxNzc0ODMxOSwiZXhwIjoyMDMzMzI0MzE5fQ.eT0_E89SJcXMMxwiQBxr0IwIhASgms4BDNRVz3CZ_xc'
    )::jsonb,
    body := json_build_object(
      'group_id', NEW.group_id,
      'sender_id', NEW.profile_id
    )::jsonb
  );

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_new_post()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM
    net.http_post(
      url := 'https://hrktxqpsqbjnockggnic.supabase.co/functions/v1/notify-new-post',
      headers := json_build_object(
        'Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhya3R4cXBzcWJqbm9ja2dnbmljIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcxNzc0ODMxOSwiZXhwIjoyMDMzMzI0MzE5fQ.eT0_E89SJcXMMxwiQBxr0IwIhASgms4BDNRVz3CZ_xc'
      )::jsonb,
      body := json_build_object(
        'post_id', NEW.id,
        'challenge_id', NEW.challenge_id,
        'sender_id', NEW.profile_id
      )::jsonb
    );

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_invite_code()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
    -- If invite_code is not provided, generate a new one
    IF NEW.invite_code IS NULL THEN
        NEW.invite_code := generate_unique_invite_code();
    END IF;

    RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_challenge_status_to_ended()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  challenge_group_id BIGINT;
  member_count INTEGER;
  vote_count INTEGER;
  current_status text;
BEGIN
  -- Get the group ID and current status of the challenge
  SELECT c.group_id, c.status::text INTO challenge_group_id, current_status
  FROM challenge c
  WHERE c.id = NEW.challenge_id;

  -- Count the number of active members in the group
  SELECT COUNT(*) INTO member_count
  FROM group_profile gp
  WHERE gp.group_id = challenge_group_id
  AND gp.profile_id IS NOT NULL;

  -- Count the number of DISTINCT voters for this challenge
  SELECT COUNT(DISTINCT v.user_id) INTO vote_count
  FROM vote v
  WHERE v.challenge_id = NEW.challenge_id;

  -- If the vote count equals the member count, update the challenge status to 'ended'
  IF vote_count >= member_count THEN
    UPDATE challenge
    SET status = 'ended'::challenge_status
    WHERE id = NEW.challenge_id
    AND status = 'voting'::challenge_status;
    
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_challenge_status_to_voting()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Get the challenge and its associated group information
    WITH challenge_info AS (
        SELECT 
            c.id AS challenge_id,
            c.group_id,
            c.status,
            (
                SELECT COUNT(*)
                FROM group_profile gp
                WHERE gp.group_id = c.group_id
            ) AS total_members,
            (
                SELECT COUNT(DISTINCT p.profile_id)
                FROM post p
                WHERE p.challenge_id = c.id
            ) AS total_posts
        FROM challenge c
        WHERE c.id = NEW.challenge_id
    )
    UPDATE challenge c
    SET status = 'voting'
    FROM challenge_info ci
    WHERE c.id = ci.challenge_id
    AND ci.status != 'voting'  -- Only update if not already in voting status
    AND ci.total_posts = ci.total_members;  -- Update only when all members have posted

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_challenge_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = new.group_id;
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_comment_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = (
    select group_id 
    from challenge 
    where id = (
      select challenge_id 
      from post 
      where id = new.post_id
    )
  );
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_group_profile_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = coalesce(new.group_id, old.group_id);
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_group_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.last_activity = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_post_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = (
    select group_id from challenge where id = coalesce(new.challenge_id, old.challenge_id)
  );
  return null;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity_on_vote_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update "group"
  set last_activity = now()
  where id = (
    select group_id 
    from challenge 
    where id = new.challenge_id
  );
  return null;
end;
$function$
;

create policy "Everyone can get"
on "public"."app_ maintenance"
as permissive
for select
to public
using (true);


create policy "Public can read app version"
on "public"."app_version"
as permissive
for select
to public
using (true);


create policy "Allow group member to read challenges"
on "public"."challenge"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = challenge.group_id) AND (gp.profile_id = auth.uid())))));


create policy "Enable insert for users based on creator_id"
on "public"."challenge"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = creator_id));


create policy "Enable update for users based on created_id"
on "public"."challenge"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = challenge.group_id) AND (gp.profile_id = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = challenge.group_id) AND (gp.profile_id = auth.uid())))));


create policy "insert_comment_if_group_member"
on "public"."comment"
as permissive
for insert
to public
with check ((EXISTS ( SELECT 1
   FROM ((group_profile gp
     JOIN challenge c ON ((c.group_id = gp.group_id)))
     JOIN post p ON ((p.challenge_id = c.id)))
  WHERE ((gp.profile_id = auth.uid()) AND (p.id = comment.post_id)))));


create policy "select_comment_if_group_member"
on "public"."comment"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM ((group_profile gp
     JOIN challenge c ON ((c.group_id = gp.group_id)))
     JOIN post p ON ((p.challenge_id = c.id)))
  WHERE ((gp.profile_id = auth.uid()) AND (p.id = comment.post_id)))));


create policy "update_delete_own_comment"
on "public"."comment"
as permissive
for all
to public
using ((creator_id = auth.uid()));


create policy "Allow group member to update group"
on "public"."group"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = "group".id) AND (gp.profile_id = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = "group".id) AND (gp.profile_id = auth.uid())))));


create policy "Allow group member, or creator to read"
on "public"."group"
as permissive
for select
to public
using (((EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE ((gp.group_id = "group".id) AND (gp.profile_id = auth.uid())))) OR (creator_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM group_profile gp
  WHERE (gp.group_id = "group".id)))));


create policy "Enable insert for authenticated users only"
on "public"."group"
as permissive
for insert
to public
with check (true);


create policy "Allow member of group to leave - delete row"
on "public"."group_profile"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = profile_id));


create policy "Enable insert for authenticated users only"
on "public"."group_profile"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read for authenticated users only"
on "public"."group_profile"
as permissive
for select
to authenticated
using (true);


create policy "Service role can access all rows"
on "public"."notification_subscription"
as permissive
for all
to service_role
using (true);


create policy "Users can upsert their own notification subscription"
on "public"."notification_subscription"
as permissive
for all
to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "Users can only insert their own posts if they are in the challe"
on "public"."post"
as permissive
for insert
to public
with check (((profile_id = auth.uid()) AND (challenge_id IN ( SELECT challenge.id
   FROM (challenge
     JOIN group_profile ON ((challenge.group_id = group_profile.group_id)))
  WHERE (group_profile.profile_id = auth.uid())))));


create policy "Users can view posts from challenges in their groups"
on "public"."post"
as permissive
for select
to public
using ((challenge_id IN ( SELECT challenge.id
   FROM (challenge
     JOIN group_profile ON ((challenge.group_id = group_profile.group_id)))
  WHERE (group_profile.profile_id = auth.uid()))));


create policy "Enable delete for users based on user_id"
on "public"."profile"
as permissive
for delete
to public
using ((auth.uid() = id));


create policy "Public profile are viewable by everyone."
on "public"."profile"
as permissive
for select
to public
using (true);


create policy "Users can insert their own profile."
on "public"."profile"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can update own profile."
on "public"."profile"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "vote_group_policy"
on "public"."vote"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM (group_profile gp
     JOIN challenge c ON ((c.group_id = gp.group_id)))
  WHERE ((gp.profile_id = auth.uid()) AND (c.id = vote.challenge_id)))));


CREATE TRIGGER on_challenge_changed AFTER INSERT OR UPDATE ON public.challenge FOR EACH ROW EXECUTE FUNCTION notify_challenge_update();

CREATE TRIGGER trigger_last_activity_on_challenge_insert AFTER INSERT ON public.challenge FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_challenge_change();

CREATE TRIGGER trigger_last_activity_on_challenge_update AFTER UPDATE ON public.challenge FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_challenge_change();

CREATE TRIGGER trigger_last_activity_on_comment_insert AFTER INSERT ON public.comment FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_comment_insert();

CREATE TRIGGER trigger_last_activity_on_group_update BEFORE UPDATE ON public."group" FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_group_update();

CREATE TRIGGER trigger_set_invite_code BEFORE INSERT ON public."group" FOR EACH ROW EXECUTE FUNCTION set_invite_code();

CREATE TRIGGER trigger_last_activity_on_group_profile_delete AFTER DELETE ON public.group_profile FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_group_profile_change();

CREATE TRIGGER trigger_last_activity_on_group_profile_insert AFTER INSERT ON public.group_profile FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_group_profile_change();

CREATE TRIGGER trigger_notify_new_group_member AFTER INSERT ON public.group_profile FOR EACH ROW EXECUTE FUNCTION notify_new_group_member();

CREATE TRIGGER auto_update_challenge_status_to_voting AFTER INSERT OR UPDATE ON public.post FOR EACH ROW EXECUTE FUNCTION update_challenge_status_to_voting();

CREATE TRIGGER trigger_last_activity_on_post_delete AFTER DELETE ON public.post FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_post_change();

CREATE TRIGGER trigger_last_activity_on_post_insert AFTER INSERT ON public.post FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_post_change();

CREATE TRIGGER trigger_last_activity_on_post_update AFTER UPDATE ON public.post FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_post_change();

CREATE TRIGGER trigger_notify_new_post AFTER INSERT ON public.post FOR EACH ROW EXECUTE FUNCTION notify_new_post();

CREATE TRIGGER auto_update_challenge_status_to_ended AFTER INSERT ON public.vote FOR EACH ROW EXECUTE FUNCTION update_challenge_status_to_ended();

CREATE TRIGGER trigger_last_activity_on_vote_insert AFTER INSERT ON public.vote FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_vote_change();

CREATE TRIGGER trigger_last_activity_on_vote_update AFTER UPDATE ON public.vote FOR EACH ROW EXECUTE FUNCTION update_last_activity_on_vote_change();


